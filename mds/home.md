Hello and welcome to my website. I like to code, write about code and sometimes post it here for my own posterity. I have been a developer for a couple decades and I **still** enjoy it very much.

> What I like about programming is that it is a puzzle that never ends.

When I started developing the landscape was small and it was possible to know enough about all of the aspects to be a considered a [full stack developer](https://hackernoon.com/the-full-stack-fallacy-why-full-stack-engineers-dont-actually-exist-1b8837383144). Currently the landscape is much larger and it is much more difficult to know about all of the [emerging frameworks](https://medium.com/javascript-scene/why-im-thankful-for-js-fatigue-i-know-you-re-sick-of-those-words-but-this-is-different-296fae0c888f) and languages. Now I just consider myself a polyglot programmer who knows a little about a lot of things.

I dabble in a lot of languages and frameworks because I think it is important to know what tools are available and what they are best used for. While it is possible to hammer a nail into a piece of wood with a screwdriver, it is better to use the right tool for the job.

[Ruby/Rails](http://rubyonrails.org/) has been a great backend setup for me in the past, but I have moved on to different languages and frameworks to keep improving. I've recently had a lot of fun going back to [PHP/Laravel](https://laravel.com/). It is nice to see where [Taylor](https://github.com/taylorotwell) and others have taken it. I actually used Laravel before I used Rails and I feel more comfortable knowing most of the dependencies are maintained by the core developers. [Erlang/Elixir/Phoenix](http://phoenixframework.org/) is **super-awesome** as well. The functional programming it embodies really helped me improve developing in other languages. I also like the [origin story](https://en.wikipedia.org/wiki/Erlang_(programming_language)#History), but maybe it is because I have telecom experience.

Currently, I really like [React](https://reactjs.org/) and [Node](https://nodejs.org/en/) because it is nice to use full-stack JavaScript. Which is also why I like [Electron](https://electronjs.org/), it lets me develop for desktop applications. [Vue.js](https://vuejs.org/) is definitely at the top of my list of favorite front-end frameworks. I really like how concise it is, and because I've gotten burned by dependencies in the past I have a soft spot for frameworks that maintain their own core dependencies. While I love [Ember](https://www.emberjs.com/), it feels like I'm reliving working with [MooTools](https://mootools.net/). MooTools was a contemporary of [JQuery](https://jquery.com/) but it didn't gain traction and eventually became obsolete. Sorry [Tom](https://tomdale.net/) and [Yahuda](http://yehudakatz.com/).

The front-end build tool landscape is also growing. I have used or tried [Bower](https://bower.io/), [Grunt](https://gruntjs.com/), [Gulp](https://gulpjs.com/), [Broccoli](https://github.com/broccolijs/broccoli), [Webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org/) and most recently [Parcel](https://parceljs.org/). I liked grunt and bower in the past. Used them for a number of projects. Going from no build tools to them was like going from [2D side scroll](https://en.wikipedia.org/wiki/Super_Mario_Bros._3) to [3D open world](https://en.wikipedia.org/wiki/Final_Fantasy_VII). Now with Webpack and Rollup, it feels like I'm building my own games. While there are pre-built options available (e.g. [ember-cli](https://ember-cli.com/), [create-react-app](https://github.com/facebookincubator/create-react-app) and [vue-cli](https://github.com/vuejs/vue-cli)) they come with a lot of magic and when things break under deadline the last thing I want to do is start deciphering those incantations only to end up with a bespoke solution that breaks on the next update. Parcel is nice and I plan on using it for a lot of my personal projects because it reduces the time to startup. I don't know if it will ever have the power of Webpack, though if it tries it will just collapse under its own configuration.

Databases have grown and the truths that were self-evident are no longer considered gospel. [MySQL](https://www.mysql.com/) outperforms [PostgeSQL](https://www.postgresql.org/) sometimes, PostgreSQL outperforms [MongoDB](https://www.mongodb.com/) sometimes. Storing serialized data can be the right choice. Enums are not always the answer and storing arrays in columns can be faster than indexed relationships. My mind has tiny explosions everytime I read some reality changing tweet or blog post by a core developer. Now there are cloud first databases that are built to scale like [FaunaDB](https://fauna.com/) and [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) which alter the way data can be maintained. The reality is that all architectural bottlenecks have been solved and we can't blame the tools. If the technology is failing us, we are probably using a screwdriver instead of a hammer.